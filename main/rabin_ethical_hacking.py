# -*- coding: utf-8 -*-
"""Rabin_Ethical Hacking

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s6f2mHUq_ZS6f43KWlPUKZZmgMzoCKMz

# **Rabin**
"""

import random
import time
import math
# import matplotlib.pyplot as plt
import signal

"""# **Key Generation**"""

def checkPrimeFermat(p):
    #if p <= 1:
     #   return False
    assert p > 2 and p % 2 == 1
    numberOfTrials = len(str(p)) * 3
    for i in range(numberOfTrials):
        a = random.randint(2, p - 1)
        if pow(a, p - 1, p) != 1:
            return False
    return True

def isBlumInteger(p, q):
    return p % 4 == 3 and q % 4 == 3

def generateTwoPrime(bit_length):
    prime_list = []
    lower_bound = 2 ** (bit_length - 1)
    upper_bound = 2 ** bit_length - 1

    while len(prime_list) < 2:
        candidate = random.randint(lower_bound, upper_bound) | 1
        if checkPrimeFermat(candidate) and candidate not in prime_list:
            prime_list.append(candidate)

    p, q = prime_list
    if isBlumInteger(p, q):
        n = p * q
        return p, q, n
    else:
        return generateTwoPrime(bit_length)

p, q, n = generateTwoPrime(15)
print(f"Private Key, p: {p} q: {q}")
print(f"Public Key, n: {n}")

"""# **Encryption**

### **Ubah teks ke desimal**
"""

def char_to_binary_decimal(message):
    results = []
    for char in message:
        ascii_value = ord(char)
        binary_value = ""
        while ascii_value > 0:
            remainder = ascii_value % 2
            binary_value = str(remainder) + binary_value
            ascii_value //= 2
        double_binary_value = binary_value + binary_value
        m = 0
        for bit in double_binary_value:
            m = (m << 1) | int(bit)
        results.append((char, ascii_value, binary_value, double_binary_value, m))
    return results

message = "Dear-J"
results = char_to_binary_decimal(message)

print(f"Plaintext: {message}")
for char, ascii_value, binary_value, double_binary_value, m in results:
    print(f"Karakter {char} memiliki nilai ASCII: {ascii_value}, Biner: {binary_value}, Biner Ganda: {double_binary_value}, Desimal: {m}")

"""### **Encryption**

"""

def encrypt(m, n):
    return pow(m, 2, n)  # c = m^2 mod n

ciphertexts = []
for char, ascii_value, binary_value, double_binary_value, m in results:
    c = encrypt(m, n)
    ciphertexts.append((c))
    print(f"PlainText: '{char}', m: {m}, Ciphertext (c): {c}")

"""# **Decryption**

### **Menghitung yp dan yq**
"""

def extendedEuclidean(p, q):
    if p == 0:
        return q, 0, 1
    gcd, x1, y1 = extendedEuclidean(q % p, p)
    yp = y1 - (q // p) * x1
    yq = x1
    return gcd, yp, yq
gcd, yp, yq = extendedEuclidean(p, q)
print(f"Coefficients: yp = {yp}, yq = {yq}")

"""### **Menghitung mp dan mq**"""

# Menghitung nilai mp dan mq
def calculate_mp_mq(c, p, q):
  mp = pow(c, (p + 1)//4, p)
  mq = pow(c, (q + 1)//4, q)

  return mp, mq

mp_mq_results = []
for c in ciphertexts:
    mp, mq = calculate_mp_mq(c, p, q)
    mp_mq_results.append((mp, mq))
    print(f"mp: {mp}, mq: {mq}")

"""### **Menghitung nilai v dan w**"""

# Fungsi untuk menghitung nilai v dan w
def calculate_v_w(yp, p, mq, yq, q, mp):
    v = yp * p * mq
    w = yq * q * mp
    return v, w

v_w_results = []
for mp, mq in mp_mq_results:
    v, w = calculate_v_w(yp, p, mq, yq, q, mp)
    v_w_results.append((v, w))
    print(f" v: {v}, w: {w}")

"""### **Menghitung nilai r,s,t,u**"""

def calculate_r_s_t_u(v, w, n):
    r = (v + w) % n
    s = (v - w) % n
    t = (-v + w) % n
    u = (-v - w) % n
    return r, s, t, u

r_s_t_u_results = []
for v,w in v_w_results:
    r, s, t, u = calculate_r_s_t_u(v, w, n)
    r_s_t_u_results.append((r, s, t, u))
    print(f" r: {r}, s: {s} t: {t}, u: {u}")

def find_values(r_s_t_u_values):
    all_values = []
    symmetric_values = []

    for idx, (r, s, t, u) in enumerate(r_s_t_u_values, start=1):
        for value, name in zip([r, s, t, u], [f"r{idx}", f"s{idx}", f"t{idx}", f"u{idx}"]):
            binary_str = ""
            original_value = value  # Menyimpan nilai asli untuk referensi

            # Mengonversi nilai ke biner
            while value > 0:
                remainder = value % 2
                binary_str = str(remainder) + binary_str
                value //= 2

            # Membagi biner menjadi dua bagian
            half_len = len(binary_str) // 2
            left_half = binary_str[:half_len]
            right_half = binary_str[half_len:]

            # Menyimpan status simetris/tidak simetris
            sym_status = "simetris" if left_half == right_half else "tidak simetris"
            all_values.append((name, binary_str, left_half, right_half, sym_status))

            if sym_status == "simetris":
                symmetric_values.append((name, binary_str, left_half, right_half, sym_status))

    return all_values, symmetric_values

all_results, symmetric_results = find_values(r_s_t_u_results)
print("Hasil Analisis Biner:")
for name, binary_str, left_half, right_half, sym_status in all_results:
    print(f"Posisi         : {name}")
    print(f"  Biner Lengkap: {binary_str}")
    print(f"  Biner Kiri   : {left_half}")
    print(f"  Biner Kanan  : {right_half}")
    print(f"  Status       : {sym_status}")
    print()

def convert_to_ascii(symmetric_values):
    decryption = []  # Untuk menyimpan karakter hasil dekripsi

    for name, binary_str, left_half, right_half, _ in symmetric_values:
        # Mengonversi biner kiri ke desimal
        decimal_value = int(left_half, 2)

        # Konversi biner kiri ke karakter ASCII
        char = chr(decimal_value)
        decryption.append({
            "position": name,
            "binary_double": binary_str,
            "binary": f"{left_half}",
            "decimal": decimal_value,
            "character": char
        })

    print("Detail Hasil Dekripsi:")
    for item in decryption:
        print(f"Posisi        : {item['position']}")
        print(f"  Biner Ganda : {item['binary_double']}")
        print(f"  Biner       : {item['binary']}")
        print(f"  Desimal     : {item['decimal']}")
        print(f"  Karakter    : {item['character']}")
        print()

    # Menggabungkan karakter hasil dekripsi untuk pesan asli
    message = ''.join([item['character'] for item in decryption])
    return message

message = convert_to_ascii(symmetric_results)
print("Pesan Hasil Dekripsi:", message)

"""# **Kriptanalisis Dengan Brute Force**"""

# Fungsi Brute Force
def brute_force (n):
  for p in range (3, int(math.sqrt(n)), 2):
    if n % p == 0:
      q = n // p
      return p, q

p_brute_force, q_brute_force = brute_force(n)
print(f"faktorisasi n = {n} adalah p = {p_brute_force} dan q = {q_brute_force}")

bit_lengths = [10, 20, 30, 40]
times = []

# Fungsi timeout
def handler(signum, frame):
    raise TimeoutError()

# Mengatur handler untuk timeout
signal.signal(signal.SIGALRM, handler)

for bit_length in bit_lengths:
    p, q, n = generateTwoPrime(bit_length)

    try:
        signal.alarm(60)
        start_time = time.time()
        p_brute_force, q_brute_force = brute_force(n)
        end_time = time.time()
        signal.alarm(0)

        elapsed_time = end_time - start_time
        times.append(min(elapsed_time, 60))
        print(f"Panjang Bit: {bit_length}, Time Taken: {elapsed_time:.6f} detik")

    except TimeoutError:
        times.append(60)
        print(f"Panjang Bit: {bit_length}, Time Taken: Timeout (1 menit)")

# # Buat grafik
# plt.plot(bit_lengths, times, marker='o')
# plt.xlabel("Panjang bit")
# plt.ylabel("Waktu faktorisasi n (detik)")
# plt.title("Grafik Faktorisasi Brute Force Time vs Panjang Bit")
# plt.xticks(bit_lengths)
# plt.grid(True)
# plt.show()